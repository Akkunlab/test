<!doctype html>
<meta charset="utf-8" />
<title>Haptic Control (Web Bluetooth)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
         margin: 0; padding: 24px; line-height: 1.4; }
  h1 { font-size: 20px; margin: 0 0 12px; }
  button { font-size: 16px; padding: 10px 14px; margin: 6px 8px 6px 0; border-radius: 8px; border: 1px solid #ccc;
           background: #fafafa; cursor: pointer; }
  #log { white-space: pre-wrap; border: 1px solid #ddd; border-radius: 8px; padding: 10px; height: 240px; overflow:auto; }
</style>

<h1>ğŸŸ¦ M5 Haptic (Web Bluetooth)</h1>
<p>
  <button id="btnConnect">ğŸ”— Connect</button>
  <button id="btnDiag" disabled>ğŸ§ª Diagnose & PING all</button>
</p>
<p>
  <button id="btnPulse" disabled>ğŸ’¥ PULSE 200ms</button>
  <button id="btnOn" disabled>â–¶ï¸ ON (click once)</button>
  <button id="btnOff" disabled>â¹ OFF</button>
</p>
<div id="log"></div>

<script>
  const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
  const RX_UUID      = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // æœŸå¾…ã™ã‚‹RX
  const TX_UUID      = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // æœŸå¾…ã™ã‚‹TX(Notify)

  let device, server, service, rxChar, txChar;
  let writableChars = []; // {ch, uuid, props}

  const log = (...args) => {
    const el = document.getElementById('log');
    el.textContent += args.join(' ') + '\n';
    el.scrollTop = el.scrollHeight;
    console.log(...args);
  };

  function setEnabled(v) {
    document.getElementById('btnDiag').disabled = !v;
    document.getElementById('btnPulse').disabled = !v;
    document.getElementById('btnOn').disabled = !v;
    document.getElementById('btnOff').disabled = !v;
  }

  async function writeAuto(ch, bytes, label) {
    const p = ch.properties || {};
    try {
      if (p.writeWithoutResponse && ch.writeValueWithoutResponse) {
        await ch.writeValueWithoutResponse(bytes);
        log(`â¡ï¸ [${short(ch.uuid)}] (wnr):`, label);
        return true;
      }
    } catch (e) {
      log(`âš ï¸ [${short(ch.uuid)}] wnr failed:`, e.message || e);
    }
    try {
      if (p.write && ch.writeValue) {
        await ch.writeValue(bytes);
        log(`â¡ï¸ [${short(ch.uuid)}] (ack):`, label);
        return true;
      }
    } catch (e) {
      log(`âš ï¸ [${short(ch.uuid)}] write failed:`, e.message || e);
    }
    log(`âŒ [${short(ch.uuid)}] No supported write method`);
    return false;
  }

  const enc = (s) => new TextEncoder().encode(s);
  const short = (u) => (u || '').toLowerCase().replace(/.*-([0-9a-f]{4})$/, '$1');

  async function connect() {
    try {
      device = await navigator.bluetooth.requestDevice({
        filters: [{ services: [SERVICE_UUID] }],
        optionalServices: [SERVICE_UUID]
      });
      device.addEventListener('gattserverdisconnected', () => log('ğŸ’” Disconnected'));

      server  = await device.gatt.connect();
      service = await server.getPrimaryService(SERVICE_UUID);

      // æœŸå¾…ã™ã‚‹RX/TXã‚’ã¾ãšè©¦ã™
      try {
        rxChar = await service.getCharacteristic(RX_UUID);
        log('ğŸ” RX found:', RX_UUID);
        log(`props(RX): write=${!!rxChar.properties.write}, wnr=${!!rxChar.properties.writeWithoutResponse}`);
      } catch { log('â„¹ï¸ RX not found by UUID; will scan all chars'); rxChar = null; }

      try {
        txChar = await service.getCharacteristic(TX_UUID);
        await txChar.startNotifications();
        txChar.addEventListener('characteristicvaluechanged', (e) => {
          const v = new TextDecoder().decode(e.target.value);
          log('ğŸ”” Notify:', v);
        });
        log('ğŸ” TX found & notifications started:', TX_UUID);
      } catch (e) {
        log('â„¹ï¸ TX notify not available:', e.message || e);
        txChar = null;
      }

      // ã‚µãƒ¼ãƒ“ã‚¹å†…ã®å…¨ã‚­ãƒ£ãƒ©åˆ—æŒ™
      const chars = await service.getCharacteristics();
      writableChars = [];
      log(`ğŸ“œ Service has ${chars.length} characteristic(s):`);
      for (const ch of chars) {
        const p = ch.properties || {};
        log(`  â€¢ ${ch.uuid}  [read=${!!p.read}, write=${!!p.write}, wnr=${!!p.writeWithoutResponse}, notify=${!!p.notify}]`);
        if (p.write || p.writeWithoutResponse) {
          writableChars.push({ ch, uuid: ch.uuid, props: p });
        }
      }

      // RXãŒæœªç¢ºå®šãªã‚‰ã€æ›¸ã‘ã‚‹å€™è£œã‹ã‚‰ NUSã® #0002 ãƒ©ã‚¤ã‚¯ã‚’å„ªå…ˆ
      if (!rxChar) {
        const prefer = writableChars.find(x => /6e400002/i.test(x.uuid));
        rxChar = (prefer || writableChars[0] || {}).ch || null;
        if (rxChar) log('âœ… RX auto-selected:', rxChar.uuid);
      }

      log('âœ… Connected to', device.name || '(no name)');
      setEnabled(true);

      // ç–é€š: æœŸå¾…RXã«PINGã€ã•ã‚‰ã«ç·å½“ãŸã‚Šã¯ã€ŒDiagnoseã€ã§å®Ÿè¡Œ
      if (rxChar) await writeAuto(rxChar, enc('PING'), 'PING');
      else log('âŒ No writable characteristic picked as RX.');

    } catch (e) {
      log('âŒ', e.message || e);
    }
  }

  // ç·å½“ãŸã‚Šãƒ†ã‚¹ãƒˆï¼šå…¨ã¦ã®ã€Œæ›¸ã‘ã‚‹ã€ã‚­ãƒ£ãƒ©ã¸ PING ã¨ ON ã‚’é€ã‚‹
  async function diagnose() {
    if (!writableChars.length) { log('âš ï¸ No writable characteristics found'); return; }
    for (const { ch, uuid } of writableChars) {
      log(`ğŸ§ª Try write to ${uuid}`);
      await writeAuto(ch, enc('PING'), 'PING');
      await new Promise(r => setTimeout(r, 150));
      await writeAuto(ch, enc('ON'), 'ON');
      await new Promise(r => setTimeout(r, 150));
    }
    log('ğŸ§ª Done.');
  }

  async function send(cmd) {
    if (!rxChar) { log('âš ï¸ RX not selected. Use Diagnose to find one.'); return; }
    await writeAuto(rxChar, enc(cmd), cmd);
  }

  document.getElementById('btnConnect').onclick = connect;
  document.getElementById('btnDiag').onclick    = diagnose;
  document.getElementById('btnPulse').onclick   = () => send('P200');
  document.getElementById('btnOn').onclick      = () => send('ON');
  document.getElementById('btnOff').onclick     = () => send('OFF');
</script>
